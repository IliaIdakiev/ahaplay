import * as path from "path";
import { ChildProcessWithoutNullStreams, spawn } from "child_process";
import { redisClient, pubSub } from "../redis";
import {
  generateRedisSessionClientName,
  generateRedisSessionProcessorName,
} from "./utils";
import {
  PubSubMessage,
  PubSubXActionMessage,
  PubSubXActionMessageResult,
  SessionProcessorMessage,
} from "./types";
import { SessionMachineActions, SessionMachineContext } from "./+xstate";
import { environment } from "../env";

const pathToSessionProcessorScript = path.join(__basedir, "index.js");

const childProcesses: ChildProcessWithoutNullStreams[] = [];

export function startSessionProcessor({
  sessionId,
}: {
  sessionId: string;
}): Promise<string> {
  const sessionProcessorName = generateRedisSessionProcessorName({
    sessionId,
  });

  return redisClient.get(sessionProcessorName).then((existingEntry) => {
    if (existingEntry) {
      return Promise.resolve(sessionProcessorName);
    }
    redisClient.set(sessionProcessorName, sessionProcessorName); // TODO: Figure out a better way to keep the session processors and their state

    let childProcess: ChildProcessWithoutNullStreams;

    const connected = new Promise<void>((res) => {
      let resolved = false;
      pubSub.subscribe(
        generateRedisSessionClientName({ sessionId }),
        (event) => {
          if (
            event?.type === SessionProcessorMessage.SESSION_PROCESSOR_STARTED &&
            resolved === false
          ) {
            resolved = true;
            res();
          }
        }
      );
    });

    try {
      childProcess = spawn("node", [
        pathToSessionProcessorScript,
        "--session-processor",
        sessionId,
      ]);
    } catch (e) {
      throw new Error("Cannot spawn process!");
    }

    function cleanup() {
      console.log("Clean up...");
    }

    function childProcessCleanup() {
      console.log("Child process clean up...");
    }

    childProcesses.push(childProcess);

    childProcess.stdout.on("data", (data) => {
      console.log(`Child Process STDOUT: ${data}`);
    });

    childProcess.stderr.on("data", (data) => {
      console.error(`Child Process STDERR: ${data}`);
    });

    // This signal is typically generated by the terminal interrupt character (Ctrl+C).
    // It's often used to request an interactive program to terminate.
    process.on("SIGINT", (signal) => {
      console.log("SIGINT");
      if (environment !== "prod") {
        childProcess.kill(signal);
      }
    });
    // This signal is generated by the terminal quit character (Ctrl+).
    // It's similar to SIGINT but also produces a core dump of the process. It's often used for debugging purposes.
    process.on("SIGQUIT", (signal) => {
      console.log("SIGQUIT");
      cleanup();
      if (environment !== "prod") {
        childProcess.kill(signal);
      }
    });
    // // This signal immediately terminates a process.
    // // Unlike other signals, it cannot be caught or ignored. It's a forceful termination.
    // process.on("SIGKILL", (signal) => {
    //   console.log("SIGKILL");
    //   cleanup();
    //   if (environment !== "prod") {
    //     childProcess.kill(signal);
    //   }
    // });

    // This signal is a request for termination.
    // Processes can listen for this signal and perform cleanup operations before exiting. It's often used for a graceful shutdown.
    process.on("SIGTERM", (signal) => {
      console.log("SIGTERM");
      cleanup();
      if (environment !== "prod") {
        childProcess.kill(signal);
      }
    });

    // This signal is sent to the parent process when a child process terminates or stops.
    // It's not directly a shutdown signal for the main process but can be used to monitor child processes.
    process.on("SIGCHLD", (signal) => {
      console.log("Child process stopped or killed");
      childProcessCleanup();
    });

    return connected.then(() => sessionProcessorName);
  });
}

export function messageSessionProcessor({
  sessionId,
  message,
}: {
  sessionId: string;
  message: any;
}) {
  return pubSub.publish(
    generateRedisSessionProcessorName({ sessionId }),
    message
  );
}

export function dispatchActionToProcessor({
  sessionId,
  action,
}: {
  sessionId: string;
  action: SessionMachineActions;
}) {
  const message: PubSubXActionMessage = {
    type: SessionProcessorMessage.DISPATCH_ACTION,
    data: { action },
  };

  return messageSessionProcessor({ sessionId, message }).then(() =>
    listenForSessionProcessorActionResult({ sessionId, action })
  );
}

export function listenForSessionProcessorActionResult({
  sessionId,
  action,
}: {
  sessionId: string;
  action: SessionMachineActions;
}) {
  return new Promise<{
    context: SessionMachineContext;
    stateValue: string;
  }>((res, rej) => {
    let subscriptionId: number | null = null;

    const handler = (message: PubSubMessage) => {
      if (
        [
          SessionProcessorMessage.UNCAUGHT_EXCEPTION,
          SessionProcessorMessage.UNHANDLED_REJECTION,
        ].includes(message.type)
      ) {
        return rej(message.data);
      }

      if (
        message.type !== SessionProcessorMessage.ACTION_RESULT ||
        (message as unknown as PubSubXActionMessageResult).data.action ===
          action
      )
        return;

      const actionResultMessage =
        message as unknown as PubSubXActionMessageResult;
      const stateValue = actionResultMessage.data.stateValue;

      res({
        context: actionResultMessage.data.context,
        stateValue:
          typeof stateValue === "string"
            ? stateValue
            : JSON.stringify(stateValue),
      });
      pubSub.unsubscribe(subscriptionId!);
    };

    pubSub
      .subscribe(generateRedisSessionClientName({ sessionId }), handler)
      .then((id) => (subscriptionId = id));
  });
}
