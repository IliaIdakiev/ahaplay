import { ChildProcessWithoutNullStreams, spawn } from "child_process";
import { PubSub } from "graphql-subscriptions";
import { RedisClientType } from "redis";

export enum ProcessorStatus {
  STARTING = "STARTING",
  STARTED = "STARTED",
  STOPPED = "STOPPED",
  FAILED = "FAILED",
  FINISHED = "FINISHED",
}

export class ProcessorManager {
  constructor(private redisClient: RedisClientType, private pubSub: PubSub) {}
  
  createProcessStatusEventName(processName: string) {
    return `${processName}-status-change`;
  }
  
  startProcess(processName: string, filePathLocation: string, args: any[]) {
      return this.redisClient
        .get(processName)
        .then((processorStatus) => {
          const processStatusChangeEventName = this.createProcessStatusEventName(processName);
          if (processorStatus && ![ProcessorStatus.FAILED, ProcessorStatus.STOPPED, ProcessorStatus.FINISHED].includes(processorStatus as ProcessorStatus)) {
            if (processorStatus === ProcessorStatus.STARTED)
              return Promise.resolve(processName);

            return new Promise((res, rej) => {
              this.pubSub.subscribe(processStatusChangeEventName, (status: ProcessorStatus) => {
                if (status === ProcessorStatus.STARTED) return res(processName)              
                rej(new Error(`Process status is: ${status}`));
              })
            });
          }

          this.redisClient.set(
            processName,
            ProcessorStatus.STARTING
          ).catch(console.error);

          let childProcess: ChildProcessWithoutNullStreams;

          try {
            childProcess = spawn("node", [
              filePathLocation,
              ...args
            ]);
          } catch (e) {
            this.redisClient.set(
              processName,
              ProcessorStatus.FAILED
            ).catch(console.error);
            throw new Error("Cannot spawn process!");
          }
          
          

          // childProcess.stdout.on("data", (data) => {
          //   console.log(`Child Process STDOUT: ${data}`);
          // });

          // childProcess.stderr.on("data", (data) => {
          //   console.error(`Child Process STDERR: ${data}`);
          // });

          // // This signal is typically generated by the terminal interrupt character (Ctrl+C).
          // // It's often used to request an interactive program to terminate.
          // process.on("SIGINT", (signal) => {
          //   console.log("SIGINT");
          //   if (environment !== "prod") {
          //     childProcess.kill(signal);
          //   }
          // });
          // // This signal is generated by the terminal quit character (Ctrl+).
          // // It's similar to SIGINT but also produces a core dump of the process. It's often used for debugging purposes.
          // process.on("SIGQUIT", (signal) => {
          //   console.log("SIGQUIT");
          //   cleanup();
          //   if (environment !== "prod") {
          //     childProcess.kill(signal);
          //   }
          // });
          // // // This signal immediately terminates a process.
          // // // Unlike other signals, it cannot be caught or ignored. It's a forceful termination.
          // // process.on("SIGKILL", (signal) => {
          // //   console.log("SIGKILL");
          // //   cleanup();
          // //   if (environment !== "prod") {
          // //     childProcess.kill(signal);
          // //   }
          // // });

          // // This signal is a request for termination.
          // // Processes can listen for this signal and perform cleanup operations before exiting. It's often used for a graceful shutdown.
          // process.on("SIGTERM", (signal) => {
          //   console.log("SIGTERM");
          //   cleanup();
          //   if (environment !== "prod") {
          //     childProcess.kill(signal);
          //   }
          // });

          // // This signal is sent to the parent process when a child process terminates or stops.
          // // It's not directly a shutdown signal for the main process but can be used to monitor child processes.
          // process.on("SIGCHLD", (signal) => {
          //   console.log("Child process stopped or killed");
          //   childProcessCleanup();
          // });

          // return connected.then(() => sessionProcessorName);
        });
    }
  },
};
